<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Loving Qwen Eval</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Radio+Canada:ital,wght@0,300..700;1,300..700&display=swap');
    :root {
      --vh: 1vh;
      --bg-page: #05020c;
      --bg-card: rgba(255, 249, 244, 0.95);
      --bg-panel: rgba(255, 255, 255, 0.9);
      --bg-input: rgba(255, 249, 244, 0.75);
      --border-subtle: rgba(240, 170, 160, 0.35);
      --text-main: #a0939d;
      --text-muted: rgba(113, 86, 114, 0.7);
      --accent: #ec4899;
      --accent-soft: rgba(236, 72, 147, 0.15);
      --radius-card: 18px;
      --shadow-card: 0 25px 60px rgba(7, 2, 12, 0.35);
      --glow-rose: rgba(255, 182, 213, 0.35);
      --pointer-x: 0.5;
      --pointer-y: 0.5;
      --pointer-shift-x: 0px;
      --pointer-shift-y: 0px;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: calc(var(--vh, 1vh) * 100);
      font-family: "Radio Canada", sans-serif;
      background: radial-gradient(circle at 20% 15%, rgba(255, 198, 223, 0.2), transparent 50%),
        radial-gradient(circle at 75% 10%, rgba(255, 255, 255, 0.12), transparent 45%),
        linear-gradient(130deg, #06020f 0%, #14031a 65%, #07000f 100%);
      color: var(--text-main);
      position: relative;
      overflow-x: hidden;
      touch-action: pan-x pan-y;
    }
    body::before,
    body::after {
      content: "";
      position: fixed;
      width: min(60vw, 720px);
      height: min(60vw, 720px);
      filter: blur(120px);
      background: radial-gradient(circle, rgba(255, 204, 229, 0.35), transparent 70%);
      z-index: 0;
      pointer-events: none;
      transform: translate3d(
        calc(var(--pointer-shift-x, 0px) * 0.3),
        calc(var(--pointer-shift-y, 0px) * 0.3),
        0
      );
      transition: transform 0.4s ease-out;
    }
    body::before { top: -10%; left: -5%; opacity: 0.9; }
    body::after { bottom: -20%; right: -10%; opacity: 0.55; }
    a{color:cornflowerblue;text-decoration:none;}
    input, textarea{
      outline:none!important;
    }
    .ambient-background {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 0;
      overflow: hidden;
    }
    .ambient-background .glow {
      position: absolute;
      width: clamp(280px, 45vw, 620px);
      height: clamp(280px, 45vw, 620px);
      background: radial-gradient(circle, rgba(255, 245, 250, 0.8), transparent 65%);
      filter: blur(90px);
      opacity: 0.4;
      --float-distance: 40px;
      --float-duration: 18s;
      --parallax-strength: 1;
      animation: floatGlow var(--float-duration) ease-in-out infinite;
      animation-delay: var(--float-delay, 0s);
      mix-blend-mode: screen;
    }
    .glow.one { top: -8%; left: 5%; --float-distance: 35px; --parallax-strength: 0.6; }
    .glow.two { bottom: -22%; right: -5%; --float-duration: 22s; opacity: 0.35; --parallax-strength: 1.1; }
    .glow.three {
      top: 30%;
      right: 25%;
      width: clamp(200px, 30vw, 420px);
      height: clamp(200px, 30vw, 420px);
      opacity: 0.3;
      --float-distance: 25px;
      --float-duration: 16s;
      --parallax-strength: 0.4;
    }
    .sparkles {
      position: absolute;
      inset: 0;
      mix-blend-mode: screen;
      filter: drop-shadow(0 0 18px rgba(255, 188, 220, 0.65));
      pointer-events: none;
    }
    .sparkles span {
      position: absolute;
      left: var(--sparkle-x, 50vw);
      top: var(--sparkle-y, 50vh);
      width: var(--sparkle-size, 6px);
      height: var(--sparkle-size, 6px);
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.95);
      box-shadow: 0 0 12px rgba(255, 189, 222, 0.75), 0 0 28px rgba(255, 169, 211, 0.45);
      animation: sparkleFloat var(--sparkle-duration, 12s) linear forwards;
      animation-delay: var(--sparkle-delay, 0s);
      opacity: 0;
    }
    @keyframes floatGlow {
      0%, 100% {
        transform: translate3d(
          calc(var(--pointer-shift-x, 0px) * var(--parallax-strength, 1)),
          calc(var(--pointer-shift-y, 0px) * var(--parallax-strength, 1)),
          0
        ) scale(1);
      }
      50% {
        transform: translate3d(
          calc(var(--pointer-shift-x, 0px) * var(--parallax-strength, 1)),
          calc(var(--pointer-shift-y, 0px) * var(--parallax-strength, 1) + var(--float-distance, 40px)),
          0
        ) scale(1.05);
      }
    }
    @keyframes sparkleFloat {
      0% {
        transform: translate3d(0, 0, 0) scale(0.6);
        opacity: 0;
      }
      10% {
        opacity: 1;
      }
      90% {
        opacity: 0.9;
      }
      100% {
        transform: translate3d(var(--drift-x, 0px), var(--drift-y, -120px), 0) scale(0);
        opacity: 0;
      }
    }
    @keyframes sparklePulse {
      0%, 100% { transform: scale(0.8); opacity: 0.6; }
      50% { transform: scale(1.3); opacity: 1; }
    }
    .app-shell { min-height: calc(var(--vh, 1vh) * 100); display: flex; flex-direction: column; position: relative; z-index: 1; }
    .app-header {
      padding: 16px 24px;
      border-bottom: none;
      border-radius: var(--radius-card) var(--radius-card) 0 0;
      display: flex; justify-content: space-between; align-items: center; gap: 16px;
    }
    .app-header-title { font-size: 20px; font-weight: 700; letter-spacing: .08em; text-transform: uppercase; color: pink; }
    .app-header-sub { font-size: 13px; color: var(--text-muted); }
    .status-pill {
      display: inline-flex; align-items: center; gap: 6px;
      padding: 6px 14px; border-radius: 999px; border: none;
      font-size: 12px;
      box-shadow: none;
      transition: background 0.2s ease, color 0.2s ease;
    }
    .status-pill.status-green { background: rgba(34, 197, 94, 0.12); color: #16a34a; }
    .status-pill.status-yellow { background: rgba(234, 179, 8, 0.12); color: #b45309; }
    .status-pill.status-red { background: rgba(239, 68, 68, 0.12); color: #dc2626; }
    .status-pill.status-pink { background: rgba(236, 72, 147, 0.15); color: #ec4899; }
    .model-status-pill {
      display: inline-flex; align-items: center; gap: 6px;
      padding: 6px 14px; border-radius: 999px;
      font-size: 12px; font-weight: 600;
      background: rgba(243, 232, 255, 0.5);
      color: #ff9dff;
      border: none;
      box-shadow: 0 10px 24px rgba(79, 70, 229, 0.15);
      transition: background 0.2s ease, color 0.2s ease;
    }
    .model-status-pill[data-phase="idle"] {
      background: rgba(187,247,208,0.35);
      color: #065f46;
    }
    .model-status-pill[data-phase="loading"] {
      background: rgba(252, 211, 77, 0.35);
      color: #92400e;
    }
    .model-status-pill[data-phase="streaming"] {
      background: rgba(190, 242, 255, 0.35);
      color: #0c4a6e;
    }
    .model-status-pill[data-phase="error"] {
      background: rgba(254,226,226,0.6);
      color: #b91c1c;
    }
    .model-status-wrapper { display: flex; align-items: center; gap: 8px; position: relative; }
    .model-spinner {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      border: 3px solid rgba(255,255,255,0.15);
      border-top-color: rgba(236, 72, 147, 0.9);
      animation: spinner-rotate 1.2s linear infinite;
    }
    .model-spinner.hidden { display: none; }
    @keyframes spinner-rotate {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .model-metrics {
      display: flex;
      flex-direction: column;
      font-size: 11px;
      color: var(--text-muted);
      gap: 4px;
      min-width: 120px;
    }
    .model-metrics span { display: block; }
    .app-main { flex: 1; padding: 24px 16px 32px; display: flex; justify-content: center; }
    .card {
      width: 100%; max-width: 900px; background: var(--bg-card);
      border-radius: var(--radius-card); box-shadow: var(--shadow-card);
      padding: 28px 30px 26px; display: flex; flex-direction: column; gap: 20px;
      border: none;
    }
    .card-title { font-size: 22px; font-weight: 600; margin: 0; }
    .card-subtitle { font-size: 14px; color: var(--text-muted); }
    .conn-bar {
      justify-content:space-between;
      display: flex; flex-wrap: wrap; gap: 10px; align-items: center;
      background: rgba(255, 255, 255, 0.92); padding: 16px 18px; border-radius: var(--radius-card);
      border: none; box-shadow: 0 20px 45px rgba(5, 0, 9, 0.12);
    }
    .conn-bar label { font-size: 12px; text-transform: uppercase; color: var(--text-muted); letter-spacing: 0.04em; }
    .conn-bar input {
      border-radius: 999px; border: none;
      background: var(--bg-input); padding: 10px 16px; font-size: 16px;
      box-shadow: inset 0 0 0 1px rgba(236, 146, 135, 0.35);
    }
    .conn-bar button {
      border-radius: 999px; border: none; padding: 8px 16px; font-size: 13px;
      background: var(--accent); color: white; cursor: pointer;
      box-shadow: 0 10px 18px rgba(185,28,133,0.25);
    }
    .conn-bar button:disabled { opacity: .5; cursor: not-allowed; }
    .auth-section { display: flex; flex-direction: column; gap: 12px; }
    .auth-forms { display: flex; flex-direction: column; gap: 12px; }
    .auth-card {
      background: var(--bg-panel); border: none;
      border-radius: var(--radius-card); padding: 16px 18px; display: flex; flex-direction: column; gap: 10px;
      box-shadow: 0 15px 35px rgba(10, 0, 12, 0.15);
    }
    .auth-card label { font-size: 12px; text-transform: uppercase; color: var(--text-muted); letter-spacing: 0.04em; }
    .auth-card input {
      border-radius: 999px; border: none;
      padding: 10px 14px; font-size: 16px; background: var(--bg-input);
      box-shadow: inset 0 0 0 1px rgba(236, 146, 135, 0.3);
    }
    .auth-card button {
      align-self: flex-start; padding: 8px 16px; border-radius: 999px;
      border: none; background: linear-gradient(120deg, #ec4899, #b91c85);
      color: #fff; cursor: pointer; box-shadow: 0 12px 24px rgba(185,28,133,0.35);
    }
  .session-bar {
      display: flex; align-items: center; gap: 12px; justify-content: space-between;
      padding: 12px 16px; border-radius: var(--radius-card);
      border: none; background: rgba(255,255,255,0.9);
      flex-shrink: 0; flex-flow: wrap;
      box-shadow: 0 12px 35px rgba(15, 0, 10, 0.12);
  }
  .session-hardware-inline {
      display: none;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      color: var(--text-muted);
      min-width: 140px;
  }
  .session-hardware-bar {
      flex: 1;
      height: 5px;
      border-radius: 999px;
      background: rgba(236, 72, 147, 0.15);
      overflow: hidden;
      position: relative;
  }
  .session-hardware-bar span {
      position: absolute;
      inset: 0;
      border-radius: 999px;
      background: linear-gradient(120deg, #ec4899, #b91c85);
      width: 0%;
      transition: width 0.4s ease;
  }
  .session-hardware-inline span:last-child {
      white-space: nowrap;
      font-size: 10px;
  }
    .hardware-panel {
      margin-top: 8px;
      padding: 12px 16px;
      border-radius: var(--radius-card);
      background: rgba(255, 255, 255, 0.9);
      box-shadow: 0 10px 20px rgba(15, 0, 10, 0.12);
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 12px;
      color: var(--text-muted);
    }
    .hardware-row {
      display: flex;
      align-items: center;
      gap: 8px;
      justify-content: space-between;
    }
    .hardware-bar {
      flex: 1;
      height: 6px;
      background: rgba(236, 72, 147, 0.1);
      border-radius: 999px;
      overflow: hidden;
      position: relative;
    }
    .hardware-bar span {
      position: absolute;
      inset: 0;
      border-radius: 999px;
      background: linear-gradient(120deg, #ec4899, #b91c85);
      width: 0%;
      transition: width 0.4s ease;
    }
    .sidebar-inline-toggle {
      display: none;
      border: none;
      border-radius: 12px;
      padding: 6px 10px;
      background: rgba(255, 255, 255, 0.92);
      color: var(--text-main);
      font-size: 14px;
      cursor: pointer;
      box-shadow: 0 10px 18px rgba(236, 146, 135, 0.25);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    .sidebar-inline-toggle:hover {
      transform: translateY(-1px);
      box-shadow: 0 12px 24px rgba(236, 146, 135, 0.35);
    }
    .sessions-sidebar.hidden + .card .session-bar .sidebar-inline-toggle {
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    .session-bar button {
      border-radius: 999px; border: none;
      background: rgba(255, 214, 230, 0.6); color: var(--text-main); padding: 6px 14px;
      cursor: pointer;
      box-shadow: 0 8px 15px rgba(236, 146, 135, 0.4);
    }
    .status-log {
      border-radius: var(--radius-card);
      border: none;
      background: rgba(255,255,255,0.92);
      padding: 12px 14px;
      min-height: 48px;
      font-size: 12px;
      color: var(--text-muted);
      display: flex;
      flex-direction: column;
      gap: 4px;
      max-height: 160px;
      overflow-y: auto;
    }
    .status-log div.ok { color: #15803d; }
    .status-log div.err { color: #be123c; }
    .chat-messages {
      flex: 1; min-height: 0; overflow-y: auto;
      background: rgba(255,255,255,0.95); border-radius: var(--radius-card);
      border: none;
      padding: 24px; display: flex; flex-direction: column; gap: 14px;
      box-shadow: inset 0 0 0 1px rgba(236, 200, 190, 0.2);
    }
    .chat-message { display: flex; flex-direction: column; gap: 4px; }
    .chat-message-user { align-items: flex-end; }
    .chat-message-assistant { align-items: flex-start; }
    .chat-meta { font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: .12em; color: var(--text-muted); }
    .chat-bubble {
      max-width: 86%; padding: 12px 16px; border-radius: 20px;
      font-size: 14px; line-height: 1.4; box-shadow: inset 0 -1px 0 rgba(255,255,255,0.5);
      position: relative;
      overflow: hidden;
    }
    .chat-bubble-user { background: #ffe4ef; border: 1px solid rgba(236,72,153,0.3); }
    .chat-bubble-assistant { background: rgba(255,255,255,0.95); border: 1px solid rgba(240,215,194,0.8); }
    .typing-reveal {
      position: absolute;
      inset: 0;
      background: inherit;
      transform-origin: left;
      animation: typingReveal 260ms ease-out forwards;
      pointer-events: none;
      z-index: 2;
    }
    @keyframes typingReveal {
      0% { transform: scaleX(1); }
      100% { transform: scaleX(0); }
    }
    .chat-input-wrap {
      display: flex; flex-direction: column; gap: 8px;
      flex-shrink: 0;
    }
    .chat-input-field {
      position: relative;
      width: 100%;
    }
    .chat-input-field-control {
      width: 100%; min-height: 55px; border-radius: 26px;
      border: none; padding: 14px 140px 14px 16px;
      font-size: 16px; background: var(--bg-input);
      font-family: inherit; box-shadow: inset 0 0 0 1px rgba(236, 180, 170, 0.35);
      transition: box-shadow 0.2s ease;
      resize: none;
    }
    .chat-input-field-control:focus {
      outline: none;
      box-shadow: inset 0 0 0 1px rgba(236, 180, 170, 0.35), 0 0 0 3px rgba(236,72,147,0.15);
    }
    .chat-input-field-control:disabled {
      background: #f5ebe1;
      cursor: not-allowed;
    }
    .chat-input-field-control.multiline {
      padding-bottom: 90px;
      resize: vertical;
    }
    .chat-input-submit {
      position: absolute;
      bottom: 5px;
      right: 5px;
      border-radius: 12px;
      padding: 6px 16px;
      font-size: 13px;
      box-shadow: 0 10px 24px rgba(185,28,133,0.35);
    }
    .btn {
      background: linear-gradient(120deg, #ec4899, #b91c85);
      border: none; border-radius: 999px;
      padding: 12px 28px; font-size: 14px; color: white; font-weight: 600;
      box-shadow: 0 18px 30px rgba(185,28,133,0.35); cursor: pointer;
    }
    .btn:disabled { opacity: .6; cursor: not-allowed; }
    .chat-hint { font-size: 12px; color: var(--text-muted); }
    .chat-area {
      display: flex; flex-direction: column; gap: 14px;
      flex: 1; min-height: 0; overflow: visible;
    }
    .reauth-action {
      margin-top: 10px;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      color: var(--text-muted);
    }
    .reauth-action button {
      border-radius: 999px;
      padding: 4px 12px;
      border: none;
      background: rgba(236, 72, 147, 0.15);
      color: #b91c85;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s ease, opacity 0.2s ease;
    }
    .reauth-action button:hover {
      transform: translateY(-1px);
      opacity: 0.85;
    }
    .chat-area.chat-disabled { opacity: 0.55; pointer-events: none; }
    .hidden { display: none !important; }
    .modal-overlay {
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(3,0,9,0.78); backdrop-filter: blur(10px);
      display: flex; align-items: center; justify-content: center;
      z-index: 1000;
      padding: 20px;
    }
    .modal-content {
      background: linear-gradient(145deg, rgba(255, 250, 246, 0.95), rgba(255, 240, 248, 0.85));
      border-radius: var(--radius-card);
      box-shadow: 0 30px 80px rgba(0,0,0,0.35), inset 0 0 1px rgba(255,255,255,0.4);
      padding: 38px 36px; max-width: 520px; width: min(520px, 100%);
      border: none;
      position: relative;
      overflow: hidden;
    }
    .modal-spinner {
      position: absolute !important;
      top: 20px;
      right: 20px;
      width: 42px;
      height: 42px;
      border-radius: 50%;
      border: 4px solid rgba(255, 255, 255, 0.45);
      border-top-color: rgba(190, 24, 93, 0.95);
      box-shadow: 0 0 18px rgba(244, 114, 182, 0.8);
      animation: modal-spinner-spin 2.4s linear infinite;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }
    .login-modal.state-connect .modal-spinner {
      opacity: 1;
    }
    .modal-content::before,
    .modal-content::after {
      content: "";
      position: absolute;
      width: 420px;
      height: 420px;
      background: radial-gradient(circle, rgba(255, 196, 223, 0.5), transparent 65%);
      filter: blur(80px);
      z-index: 0;
    }
    .modal-content::before { top: -35%; left: -20%; opacity: 0.8; }
    .modal-content::after { bottom: -40%; right: -25%; opacity: 0.6; }
    .modal-content > * { position: relative; z-index: 2; }
    .modal-sparkles {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 1;
      mix-blend-mode: screen;
    }
    .modal-sparkles span {
      position: absolute;
      display: block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.95);
      box-shadow: 0 0 15px rgba(255, 189, 222, 0.7), 0 0 40px rgba(255, 169, 211, 0.45);
      animation: sparklePulse 5s ease-in-out infinite;
    }
    .modal-sparkles span:nth-child(1) { top: 18%; left: 20%; }
    .modal-sparkles span:nth-child(2) { top: 8%; right: 15%; animation-delay: 1s; }
    .modal-sparkles span:nth-child(3) { bottom: 18%; left: 28%; animation-delay: 2s; }
    .modal-sparkles span:nth-child(4) { bottom: 12%; right: 20%; animation-delay: 3s; }
    @keyframes modal-spinner-spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .modal-title {
      font-size: 24px; font-weight: 700; margin: 0 0 8px 0;
      color: #ec4899;
    }
    .modal-subtitle {
      font-size: 14px; color: var(--text-muted); margin: 0 0 24px 0;
    }
    .view-login .chat-interface { display: none !important; }
    .view-chat .login-modal { display: none !important; }

    /* Login flow states */
    .login-modal.state-connect .auth-section { display: none; }
    .login-modal.state-auth .conn-bar { display: none; }
    .markdown-body {
      font-size: 14px;
      position: relative;
    }
    .markdown-body pre {
      background: #111827; color: #f8fafc; padding: 8px 10px;
      border-radius: 8px; overflow-x: auto; font-size: 12px;
    }

    /* Sessions Sidebar */
    .chat-interface { display: flex; flex-direction: column; }
    .app-main { display: flex; flex-direction: row; gap: 0; align-items: stretch; }
    .sessions-sidebar {
      width: 260px; background: rgba(255,252,249,0.92);
      border-right: none;
      border-radius: var(--radius-card) 0 0 var(--radius-card);
      display: flex; flex-direction: column; gap: 14px; padding: 18px;
      transition: margin-left 0.3s ease, opacity 0.3s ease;
      max-height: calc(var(--vh, 1vh) * 100 - 150px); overflow: hidden;
      box-shadow: 0 20px 45px rgba(5, 0, 8, 0.18);
      backdrop-filter: blur(10px);
    }
    .sessions-sidebar.hidden {
      margin-left: -260px; opacity: 0; pointer-events: none;
    }
    .sidebar-header {
      display: flex; justify-content: space-between; align-items: center;
      padding-bottom: 8px; border-bottom: 1px solid rgba(240, 215, 194, 0.5);
    }
    .sidebar-title {
      font-size: 14px; font-weight: 700; text-transform: uppercase;
      letter-spacing: 0.08em; color: var(--text-main);
    }
    .sidebar-toggle-btn {
      background: transparent; border: 1px solid var(--border-subtle);
      border-radius: 8px; padding: 6px 10px; cursor: pointer;
      font-size: 16px; line-height: 1; color: var(--text-main);
      transition: all 0.2s;
    }
    .sidebar-toggle-btn:hover {
      background: var(--accent-soft); border-color: var(--accent);
    }
    .new-chat-btn {
      width: 100%; background: linear-gradient(120deg, #ec4899, #b91c85);
      border: none; border-radius: 999px; padding: 10px 16px;
      font-size: 13px; font-weight: 600; color: white;
      cursor: pointer; box-shadow: 0 6px 16px rgba(185,28,133,0.3);
      display: flex; align-items: center; justify-content: center; gap: 8px;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    .new-chat-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(185,28,133,0.4);
    }
    .sessions-list {
      display: flex; flex-direction: column; gap: 6px;
      flex: 1; overflow-y: auto; min-height: 0;
      margin: -1rem; padding: 1rem;
    }
    .session-item {
      background: rgba(255,255,255,0.9); border: none;
      border-radius: 12px; padding: 12px 14px; cursor: pointer;
      transition: all 0.2s; display: flex; justify-content: space-between;
      align-items: center; gap: 8px;
      box-shadow: 0 10px 18px rgba(18, 5, 12, 0.12);
    }
    .session-item:hover {
      background: rgba(255,255,255,0.98);
      transform: translateY(2px) scale(1.01);
    }
    .session-item.active {
      background: rgba(255,223,235,0.9); border: none;
      box-shadow: 0 12px 20px rgba(185,28,133,0.25);
    }
    .session-item-content {
      flex: 1; min-width: 0;
    }
    .session-item-title {
      font-size: 13px; font-weight: 600; color: var(--text-main);
      white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    }
    .session-item-meta {
      font-size: 10px; color: var(--text-muted);
      margin-top: 2px;
    }
    .session-item-delete {
      background: transparent; border: none; padding: 4px 8px;
      cursor: pointer; font-size: 16px; color: var(--text-muted);
      opacity: 0; transition: opacity 0.2s, color 0.2s;
      border-radius: 6px;
    }
    .session-item:hover .session-item-delete {
      opacity: 1;
    }
    .session-item-delete:hover {
      color: #dc2626; background: rgba(220,38,38,0.1);
    }
    .card {
      border-radius: 0 var(--radius-card) var(--radius-card) 0;
      max-height: calc(var(--vh, 1vh) * 100 - 150px); display: flex; flex-direction: column;
      overflow: hidden;
    }
    .sessions-sidebar.hidden + .card {
      border-radius: var(--radius-card);
    }

    @media (max-width: 640px) {
      .app-header{
        padding:0.5rem 1rem 0rem;
        max-height:2rem;
        overflow:clip;
      }
      .app-main{
        padding:1rem;
      }
      .modal-content{
        padding:1rem;
      }
      .card { 
        background: unset;
        width: 100%;
        padding: unset;
        box-sizing: border-box;
        box-shadow: unset;}
      .chat-bubble { max-width: 100%; }
      .chat-messages{ padding: 16px; min-height: 200px;}
      .chat-textarea { min-height: 60px; }
      .conn-bar { flex-direction: column; align-items: stretch; }
      .sessions-sidebar { 
        width: calc(100% - 2rem);
        border-radius: 1rem;position: absolute; z-index: 100; height: 100%; }
      .chat-interface.sidebar-hidden .chat-main-content {
        padding-left: 16px;
      }
      .hardware-panel {
        display: none;
      }
      .session-bar {
        align-items: flex-start;
      }
      .session-bar .model-metrics {
        order: 4;
        flex-direction: row;
        gap: 12px;
      }
      .session-hardware-inline {
        order: 5;
        display: flex;
        width: 100%;
      }
      .session-hardware-inline[data-gpu-available="false"] {
        display: none;
      }
      .session-hardware-bar {
        width: 100px;
        height: 4px;
      }
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/nkn-sdk@1.3.6/dist/nkn.min.js"></script>
</head>
<body class="view-login">
<div class="ambient-background">
  <div class="glow one"></div>
  <div class="glow two"></div>
  <div class="glow three"></div>
  <div class="sparkles"></div>
</div>
<div class="app-shell">

  <!-- Login Modal View -->
  <div class="login-modal modal-overlay state-connect">
    <div class="modal-content">
      <div class="modal-sparkles">
        <span></span>
        <span></span>
        <span></span>
        <span></span>
      </div>
      <div class="modal-spinner" role="status" aria-live="polite" aria-label="Waiting for NKN relay connection"></div>
      <h1 class="modal-title">NOVA-Q <b id="kindness">LOVES</b></h1>
      <p class="modal-subtitle" id="modal-subtitle">Connect to NKN relay to begin</p>

      <div class="conn-bar" id="conn-bar">
        <label for="pubkey-input">Relay Pubkey</label>
        <input id="pubkey-input" placeholder="64 hex characters" autocomplete="off">
        <label for="relay-address">Computed Address</label>
        <input id="relay-address" readonly>
        <!--<button type="button" id="copy-address">Copy</button>-->
        <button type="button" id="nkn-connect" disabled>Connect</button>
      </div>

      <div class="auth-section" id="auth-section">
        <div class="auth-forms">
          <form id="login-form" class="auth-card">
            <strong>Sign in to continue</strong>
            <label for="login-username">Username</label>
            <input id="login-username" autocomplete="username">
            <label for="login-password">Password</label>
            <input id="login-password" type="password" autocomplete="current-password">
            <button type="submit">Login</button>
            <button type="button" id="show-register" style="background: transparent; color: var(--text-muted); box-shadow: none; margin-top: 8px;">Need an account? Register</button>
          </form>
          <form id="register-form" class="auth-card hidden">
            <strong>Create new account</strong>
            <label for="register-username">Username</label>
            <input id="register-username" autocomplete="username">
            <label for="register-password">Password (min 6 chars)</label>
            <input id="register-password" type="password" autocomplete="new-password">
            <button type="submit">Register</button>
            <button type="button" id="show-login" style="background: transparent; color: var(--text-muted); box-shadow: none; margin-top: 8px;">Have an account? Login</button>
          </form>
        </div>
        <div class="status-log" id="activity-log">
          <div>Awaiting relay pubkey…</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Chat Interface View -->
  <div class="chat-interface">
    <header class="app-header">
      <div>
        <div class="app-header-title">NOVA-Q</div>
      </div>
      <div class="app-header-right">
          <span class="status-pill" id="nkn-status-chat">Connected</span>
      </div>
    </header>
    <main class="app-main">
      <!-- Sessions Sidebar -->
      <aside class="sessions-sidebar" id="sessions-sidebar">
        <div class="sidebar-header">
          <span class="sidebar-title">Chats</span>
          <button class="sidebar-toggle-btn" id="sidebar-toggle" title="Toggle sidebar">☰</button>
        </div>
        <button class="new-chat-btn" id="new-chat-btn">
          <span>+</span> New Chat
        </button>
        <div class="sessions-list" id="sessions-list">
          <!-- Sessions will be rendered here -->
        </div>
      </aside>

      <section class="card">
        <div class="session-bar">
          <button class="sidebar-inline-toggle" id="sidebar-toggle-inline" title="Show chats">☰</button>
          <span id="session-status">Not signed in.</span>
          <div class="model-status-wrapper">
            <span class="model-status-pill" id="model-status-pill" data-phase="idle">Model idle</span>
            <span class="model-spinner hidden" id="model-spinner" aria-hidden="true"></span>
          </div>
          <div class="model-metrics">
            <span id="model-latency">Latency · —</span>
            <span id="model-tps">TPS · —</span>
          </div>
          <div class="session-hardware-inline" id="session-hardware-inline" data-gpu-available="false" aria-hidden="true">
            <div class="session-hardware-bar">
              <span id="session-gpu-util-bar"></span>
            </div>
            <span id="session-gpu-util-label-small">—%</span>
          </div>
          <button type="button" id="logout-btn" aria-label="Log out">
            <svg width="18" height="18" viewBox="0 0 24 24" role="img" aria-hidden="true" focusable="false" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round">
              <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"/>
              <polyline points="16 17 21 12 16 7"/>
              <line x1="21" y1="12" x2="9" y2="12"/>
            </svg>
          </button>
        </div>
        <div class="hardware-panel" id="hardware-panel">
          <div class="hardware-row">
            <span>GPU Util</span>
            <div class="hardware-bar">
              <span id="gpu-util-bar"></span>
            </div>
            <span id="gpu-util-label">—%</span>
          </div>
          <div class="hardware-row">
            <span>GPU Memory</span>
            <span id="gpu-mem-label">— / — MB</span>
          </div>
          <div class="hardware-row">
            <span>Temp</span>
            <span id="gpu-temp-label">—°C</span>
          </div>
          <div class="hardware-row">
            <span>Status</span>
            <span id="hardware-status-label">Unknown</span>
          </div>
        </div>
        <div id="chat-area" class="chat-area">
          <div class="chat-messages" id="chat-messages"></div>
          <form id="chat-form" class="chat-input-wrap">
            <div class="chat-input-field">
              <input id="chat-input" type="text" class="chat-input-field-control" placeholder="Offer a question or reflection for NOVA-Q…" required autocomplete="off">
              <button class="btn chat-input-submit" type="submit" id="send-btn" aria-label="Send message">↗</button>
            </div>
          </form>
        </div>
      </section>
    </main>
  </div>
</div>
<script>
initAmbientMotion();
initSparkleField();
disableZoomGestures();

function initAmbientMotion(){
  const rootStyle = document.documentElement.style;
  const pointer = {
    currentX: 0.5,
    currentY: 0.5,
    targetX: 0.5,
    targetY: 0.5,
  };

  function handlePointerMove(event){
    const ratioX = event.clientX / window.innerWidth;
    const ratioY = event.clientY / window.innerHeight;
    pointer.targetX = Math.min(Math.max(ratioX, 0), 1);
    pointer.targetY = Math.min(Math.max(ratioY, 0), 1);
  }

  function resetPointer(){
    pointer.targetX = 0.5;
    pointer.targetY = 0.5;
  }

  function tick(){
    pointer.currentX += (pointer.targetX - pointer.currentX) * 0.08;
    pointer.currentY += (pointer.targetY - pointer.currentY) * 0.08;
    const shiftX = (pointer.currentX - 0.5) * 220;
    const shiftY = (pointer.currentY - 0.5) * 220;
    rootStyle.setProperty('--pointer-x', pointer.currentX.toFixed(4));
    rootStyle.setProperty('--pointer-y', pointer.currentY.toFixed(4));
    rootStyle.setProperty('--pointer-shift-x', `${shiftX}px`);
    rootStyle.setProperty('--pointer-shift-y', `${shiftY}px`);
    requestAnimationFrame(tick);
  }

  window.addEventListener('pointermove', handlePointerMove, { passive: true });
  window.addEventListener('pointerleave', resetPointer);
  window.addEventListener('pointerdown', handlePointerMove, { passive: true });
  tick();
}

function initSparkleField(){
  const layer = document.querySelector('.sparkles');
  if (!layer) return;

  function spawnSparkle(){
    if (layer.childElementCount > 60) return;
    const sparkle = document.createElement('span');
    const size = 4 + Math.random() * 6;
    sparkle.style.setProperty('--sparkle-size', `${size}px`);
    const startX = Math.random() * 100;
    const startY = Math.random() * 100;
    sparkle.style.setProperty('--sparkle-x', `${startX}vw`);
    sparkle.style.setProperty('--sparkle-y', `${startY}vh`);
    const driftX = (Math.random() - 0.5) * 240;
    const driftY = (Math.random() - 0.25) * 240;
    sparkle.style.setProperty('--drift-x', `${driftX}px`);
    sparkle.style.setProperty('--drift-y', `${driftY}px`);
    const duration = 9 + Math.random() * 10;
    const delay = Math.random() * 1.5;
    sparkle.style.setProperty('--sparkle-duration', `${duration}s`);
    sparkle.style.setProperty('--sparkle-delay', `${delay}s`);
    sparkle.addEventListener('animationend', () => sparkle.remove());
    layer.appendChild(sparkle);
  }

  for (let i = 0; i < 14; i++){
    setTimeout(spawnSparkle, i * 180);
  }

  setInterval(spawnSparkle, 600);
}

function disableZoomGestures(){
  const prevent = (event) => event.preventDefault();
  ['gesturestart', 'gesturechange'].forEach((type) => {
    document.addEventListener(type, prevent, { passive: false });
  });
  document.addEventListener('touchmove', (event) => {
    if (event.touches.length > 1 || (event.scale && event.scale !== 1)) {
      event.preventDefault();
    }
  }, { passive: false });
  let lastTouchEnd = 0;
  document.addEventListener('touchend', (event) => {
    const now = Date.now();
    if (event.touches.length === 0 && now - lastTouchEnd < 350) {
      event.preventDefault();
    }
    lastTouchEnd = now;
  }, { passive: false });
}

const AUTO_LOGIN_KEY = 'loving.autologin';

// Parse URL parameter for relay server endpoint
function parseRelayFromURL(){
  const urlParams = new URLSearchParams(window.location.search);
  const serverParam = urlParams.get('server');
  if (serverParam && /^[0-9a-f]{64}$/i.test(serverParam)){
    const normalized = serverParam.toLowerCase();
    localStorage.setItem('loving.pubkey', normalized);
    console.log('[init] Relay pubkey loaded from URL parameter');
    return normalized;
  }
  return null;
}

// Check URL parameter first, fallback to localStorage
const urlRelay = parseRelayFromURL();

const state = {
  relayPubkey: urlRelay || localStorage.getItem('loving.pubkey') || '',
  relay: '',
  relayVerified: false,
  relayInfo: null,
  session: null,
  currentSessionId: null,
  sessions: [],
  messages: [],
  busy: false,
  pendingSend: false,
  nkn: {
    seed: null,
    client: null,
    ready: false,
    pending: new Map(),
    pendingCounter: 0,
    connectPromise: null,
    addr: '',
    reconnectTimer: null,
    backoffMs: 1000,
    baseBackoffMs: 1000,
    maxBackoffMs: 20000,
    healthInterval: null,
  },
  autoLoginTried: false,
  autoLoginInProgress: false,
  savedCreds: null,
  modelStatus: { phase: 'idle', description: 'Model idle', meta: {} },
};

state.nkn.seed = getOrCreateSeed();
state.savedCreds = loadSavedCreds();

const els = {
  loginModal: document.querySelector('.login-modal'),
  modalSubtitle: document.getElementById('modal-subtitle'),
  pubkeyInput: document.getElementById('pubkey-input'),
  relayAddress: document.getElementById('relay-address'),
  copyAddress: document.getElementById('copy-address'),
  connectBtn: document.getElementById('nkn-connect'),
  nknStatusChat: document.getElementById('nkn-status-chat'),
  connBar: document.getElementById('conn-bar'),
  authSection: document.getElementById('auth-section'),
  chatArea: document.getElementById('chat-area'),
  chatInterface: document.querySelector('.chat-interface'),
  modelStatusPill: document.getElementById('model-status-pill'),
  modelSpinner: document.getElementById('model-spinner'),
  modelLatency: document.getElementById('model-latency'),
  modelTps: document.getElementById('model-tps'),
  sessionsSidebar: document.getElementById('sessions-sidebar'),
  sidebarToggle: document.getElementById('sidebar-toggle'),
  sidebarInlineToggle: document.getElementById('sidebar-toggle-inline'),
  newChatBtn: document.getElementById('new-chat-btn'),
  sessionsList: document.getElementById('sessions-list'),
  registerForm: document.getElementById('register-form'),
  registerUser: document.getElementById('register-username'),
  registerPass: document.getElementById('register-password'),
  loginForm: document.getElementById('login-form'),
  loginUser: document.getElementById('login-username'),
  loginPass: document.getElementById('login-password'),
  showRegisterBtn: document.getElementById('show-register'),
  showLoginBtn: document.getElementById('show-login'),
  logoutBtn: document.getElementById('logout-btn'),
  sessionStatus: document.getElementById('session-status'),
  activity: document.getElementById('activity-log'),
  hardwarePanel: document.getElementById('hardware-panel'),
  gpuUtilBar: document.getElementById('gpu-util-bar'),
  gpuUtilLabel: document.getElementById('gpu-util-label'),
  gpuMemLabel: document.getElementById('gpu-mem-label'),
  gpuTempLabel: document.getElementById('gpu-temp-label'),
  hardwareStatusLabel: document.getElementById('hardware-status-label'),
  chat: document.getElementById('chat-messages'),
  input: document.getElementById('chat-input'),
  form: document.getElementById('chat-form'),
  sendBtn: document.getElementById('send-btn'),
  sessionHardwareInline: document.getElementById('session-hardware-inline'),
  sessionGpuUtilBarInline: document.getElementById('session-gpu-util-bar'),
  sessionGpuUtilLabelInline: document.getElementById('session-gpu-util-label-small'),
};

function toast(text, ok=true){
  if (els.nknStatusChat) {
    els.nknStatusChat.textContent = text;
    els.nknStatusChat.className = 'status-pill ' + (ok ? 'ok' : 'err');
  }
  logActivity(text, ok);
}

function switchToView(viewName){
  document.body.className = `view-${viewName}`;
}

function showLoginForm(){
  els.loginForm.classList.remove('hidden');
  els.registerForm.classList.add('hidden');
}

function showRegisterForm(){
  els.registerForm.classList.remove('hidden');
  els.loginForm.classList.add('hidden');
}

function getOrCreateSeed(){
  let existing = localStorage.getItem('loving.nkn.seed');
  if (existing && /^[0-9a-f]{64}$/i.test(existing)){
    const normalized = existing.toLowerCase();
    if (existing !== normalized){
      localStorage.setItem('loving.nkn.seed', normalized);
    }
    return normalized;
  }
  const arr = new Uint8Array(32);
  window.crypto.getRandomValues(arr);
  const hex = Array.from(arr, (b) => b.toString(16).padStart(2, '0')).join('');
  localStorage.setItem('loving.nkn.seed', hex);
  return hex;
}

function loadSavedCreds(){
  try {
    const raw = localStorage.getItem(AUTO_LOGIN_KEY);
    if (!raw) return null;
    const data = JSON.parse(raw);
    if (data && data.username && data.password){
      return { username: String(data.username), password: String(data.password) };
    }
  } catch (err){
    console.warn('Failed to load auto-login creds', err);
  }
  return null;
}

function isInvalidCredentialsError(err){
  if (!err) return false;
  const msg = (err && err.message ? String(err.message) : String(err)).toLowerCase();
  return msg.includes('invalid credentials') || msg.includes('invalid username') || msg.includes('invalid password');
}

function saveCredentials(username, password){
  if (!username || !password) return;
  try {
    localStorage.setItem(
      AUTO_LOGIN_KEY,
      JSON.stringify({ username, password })
    );
    state.savedCreds = { username, password };
    prefillSavedCreds();
  } catch (err){
    console.warn('Failed to save creds', err);
  }
}

function prefillSavedCreds(){
  if (!els) return;
  if (state.savedCreds){
    els.loginUser.value = state.savedCreds.username || '';
    els.loginPass.value = state.savedCreds.password || '';
    return;
  }
  if (els.loginUser) els.loginUser.value = '';
  if (els.loginPass) els.loginPass.value = '';
}

function bindChatInputEvents(){
  if (!els.input) return;
  els.input.removeEventListener('input', handleChatInputInputEvent);
  els.input.removeEventListener('keydown', handleChatInputKeydownEvent);
  els.input.addEventListener('input', handleChatInputInputEvent);
  els.input.addEventListener('keydown', handleChatInputKeydownEvent);
  checkExpandInputOverflow();
}

function handleChatInputInputEvent(){
  const input = els.input;
  if (!input) return;
  if (isMobileViewport()){
    if (input.tagName.toLowerCase() === 'textarea'){
      downgradeChatInputToInput();
    }
    return;
  }
  if (input.tagName.toLowerCase() === 'input'){
    checkExpandInputOverflow();
  } else {
    if (shouldDowngradeTextarea(input)){
      downgradeChatInputToInput();
      return;
    }
    adjustTextareaHeight(input);
  }
}

function handleChatInputKeydownEvent(event){
  if (isMobileViewport()) return;
  if (!els.input) return;
  if (els.input.tagName.toLowerCase() === 'input' && (event.ctrlKey || event.metaKey) && event.key === 'Enter'){
    event.preventDefault();
    upgradeChatInputToTextarea({ addNewline: true });
  }
}

function checkExpandInputOverflow(){
  if (isMobileViewport()) return;
  const input = els.input;
  if (!input || input.tagName.toLowerCase() !== 'input') return;
  if (!input.value) return;
  if (input.scrollWidth > input.clientWidth + 20){
    upgradeChatInputToTextarea();
  }
}

function upgradeChatInputToTextarea({ addNewline = false } = {}){
  if (isMobileViewport()) return;
  const input = els.input;
  if (!input || input.tagName.toLowerCase() === 'textarea') return;
  const wrapper = document.querySelector('.chat-input-field');
  if (!wrapper) return;
  const value = input.value || '';
  const textarea = document.createElement('textarea');
  textarea.id = 'chat-input';
  textarea.className = `${input.className} multiline`;
  textarea.placeholder = input.placeholder || '';
  textarea.autocomplete = input.autocomplete;
  textarea.spellcheck = input.spellcheck;
  textarea.required = input.required;
  textarea.rows = 3;
  textarea.value = value + (addNewline ? '\n' : '');
  wrapper.replaceChild(textarea, input);
  els.input = textarea;
  bindChatInputEvents();
  adjustTextareaHeight(textarea);
  textarea.focus();
  textarea.selectionStart = textarea.selectionEnd = textarea.value.length;
}

function downgradeChatInputToInput(){
  const textarea = els.input;
  if (!textarea || textarea.tagName.toLowerCase() === 'input') return;
  const wrapper = document.querySelector('.chat-input-field');
  if (!wrapper) return;
  const value = textarea.value || '';
  const input = document.createElement('input');
  input.id = 'chat-input';
  input.type = 'text';
  input.className = textarea.className.replace(/\bmultiline\b/g, '').trim();
  input.placeholder = textarea.placeholder || '';
  input.autocomplete = textarea.autocomplete;
  input.spellcheck = textarea.spellcheck;
  input.required = textarea.required;
  input.value = value;
  wrapper.replaceChild(input, textarea);
  els.input = input;
  bindChatInputEvents();
  input.focus();
  input.selectionStart = input.selectionEnd = input.value.length;
}

function shouldDowngradeTextarea(textarea){
  if (!textarea || textarea.tagName.toLowerCase() !== 'textarea') return false;
  const value = textarea.value || '';
  if (value.includes('\n')) return false;
  const style = window.getComputedStyle(textarea);
  const lineHeight = parseFloat(style.lineHeight) || 20;
  const paddingTop = parseFloat(style.paddingTop) || 0;
  const paddingBottom = parseFloat(style.paddingBottom) || 0;
  const innerHeight = textarea.scrollHeight - paddingTop - paddingBottom;
  const fitsWithoutWrapping = textarea.scrollWidth <= textarea.clientWidth + 4;
  return innerHeight <= lineHeight * 1.5 && fitsWithoutWrapping;
}

function adjustTextareaHeight(textarea){
  textarea.style.height = 'auto';
  textarea.style.height = `${textarea.scrollHeight}px`;
}

function logActivity(text, ok=true){
  if (!els.activity) return;
  const line = document.createElement('div');
  line.textContent = `[${new Date().toLocaleTimeString()}] ${text}`;
  line.className = ok ? 'ok' : 'err';
  els.activity.prepend(line);
  const items = Array.from(els.activity.children);
  items.slice(20).forEach((node) => node.remove());
}

function shouldRetryNknError(err){
  const msg = String(err && err.message || err || '').toLowerCase();
  return msg.includes('message timeout') || msg.includes('failed to send') || msg.includes('timeout');
}

function resetNknClient(){
  try {
    if (state.nkn.client && state.nkn.client.close) state.nkn.client.close();
  } catch (_) {
    // ignore
  }
  state.nkn.client = null;
  state.nkn.ready = false;
  state.nkn.addr = '';
  state.nkn.connectPromise = null;
  scheduleNknReconnect('reset');
}

function scheduleNknReconnect(reason){
  if (state.nkn.reconnectTimer) return;
  const delay = state.nkn.backoffMs = Math.min(state.nkn.backoffMs * 1.5, state.nkn.maxBackoffMs);
  logActivity(`NKN reconnect scheduled (${reason}) in ${(delay/1000).toFixed(1)}s`);
  state.nkn.reconnectTimer = setTimeout(() => {
    state.nkn.reconnectTimer = null;
    ensureNknClient().catch((err) => logActivity(`Reconnect failed: ${err.message || err}`, false));
  }, delay);
}

function startNknHealthMonitor(){
  stopNknHealthMonitor();
  state.nkn.healthInterval = setInterval(() => {
    if (!state.nkn.ready) return;
    ensureRelayReady().catch((err) => logActivity(`Relay ping failed: ${err.message || err}`, false));
  }, 20000);
}

function stopNknHealthMonitor(){
  if (state.nkn.healthInterval){
    clearInterval(state.nkn.healthInterval);
    state.nkn.healthInterval = null;
  }
}

function computeAddress(pubkey){
  const clean = (pubkey || '').trim();
  if (!clean) return '';
  if (clean.includes('.') && clean.length > 10){
    return clean;
  }
  return `loving-relay.${clean}`;
}

function syncRelayInputs(){
  state.relayPubkey = (els.pubkeyInput.value || '').trim();
  localStorage.setItem('loving.pubkey', state.relayPubkey);
  state.relay = computeAddress(state.relayPubkey);
  els.relayAddress.value = state.relay;
  state.relayVerified = false;
  state.relayInfo = null;
  els.connectBtn.disabled = !state.relay;
  if (!state.relay){
    toast('Pubkey required', false);
    state.nkn.addr = '';
    return;
  }
  if (!state.nkn.ready && !state.nkn.connectPromise){
    toast('Connecting to NKN…', true);
    logActivity('Starting NKN connection...');
    ensureNknClient().catch(err => {
      toast(String(err), false);
      logActivity(`NKN connection failed: ${err}`, false);
    });
  } else if (state.nkn.ready) {
    // NKN already connected, check relay (maybe trigger auto-login)
    checkRelay()
      .then(() => ensureAutoLogin('nkn ready').catch(() => {}))
      .catch((err) => toast(err.message || 'Relay probe failed', false));
  }
}

function requireRelay(){
  if (!state.relay){
    toast('Enter relay pubkey first', false);
    return false;
  }
  return true;
}

async function ensureRelayReady(){
  if (!requireRelay()) throw new Error('Relay address required');
  if (state.relayVerified) return state.relayInfo;
  try {
    return await checkRelay();
  } catch (err){
    state.relayVerified = false;
    state.relayInfo = null;
    logActivity(`Relay probe failed: ${err.message || err}`, false);
    return null;
  }
}

async function checkRelay(){
  if (!requireRelay()) throw new Error('Relay address required');
  const info = await nknSendRequestWithRetry({ event: 'relay.info' });
  state.relayVerified = true;
  state.relayInfo = info;
  const summary = info && info.model ? `Relay ready · model ${info.model}` : 'Relay info received';
  logActivity(summary, true);
  setNknStatus('green', 'Connected', getPeerCount(info));
  if (info && info.model && state.modelStatus.phase === 'idle'){
    setModelStatus('idle', { description: `${info.model} ready`, model: info.model });
  }

  await ensureAutoLogin('relay probe');

  return info;
}

function switchLoginModalState(newState){
  // newState: 'connect' or 'auth'
  els.loginModal.classList.remove('state-connect', 'state-auth');
  els.loginModal.classList.add(`state-${newState}`);

  if (newState === 'auth') {
    els.modalSubtitle.textContent = 'Secure authenticated AI chat over NKN relay';
  } else {
    els.modalSubtitle.textContent = 'Connect to NKN relay to begin';
  }
}

function updateSessionUI(){
  if (state.session){
    els.sessionStatus.textContent = `Hi ${state.session.username}`;
    els.sendBtn.disabled = state.busy;
    switchToView('chat');
  } else {
    els.sessionStatus.textContent = 'Not signed in.';
    els.sendBtn.disabled = true;
    switchToView('login');
  }
}

function describeModelPhase(phase, meta = {}){
  const modelName = meta.model || (state.relayInfo && state.relayInfo.model) || 'model';
  switch (phase){
    case 'loading':
      return `Loading ${modelName}…`;
    case 'streaming':
      return 'Streaming response…';
    case 'error':
      return meta.detail ? `Model error · ${meta.detail}` : 'Model error';
    case 'idle':
    default:
      return `${modelName} ready`;
  }
}

const statusColorClasses = ['status-green', 'status-yellow', 'status-red', 'status-pink'];

function applyIndicatorColor(el, colorClass){
  if (!el) return;
  statusColorClasses.forEach((cls) => el.classList.toggle(cls, cls === colorClass));
}

function phaseToColor(phase){
  switch (phase){
    case 'loading':
      return 'status-yellow';
    case 'error':
      return 'status-red';
    case 'streaming':
    case 'idle':
    default:
      return 'status-green';
  }
}

function setModelStatus(phase, meta = {}){
  const description = meta.description || meta.message || describeModelPhase(phase, meta);
  state.modelStatus = { phase, description, meta };
  if (els.modelStatusPill){
    els.modelStatusPill.textContent = description;
    els.modelStatusPill.dataset.phase = phase;
    applyIndicatorColor(els.modelStatusPill, phaseToColor(phase));
    setModelSpinner(phase === 'loading');
    if (meta.detail || meta.error){
      els.modelStatusPill.title = meta.detail || meta.error;
    } else if (meta.model || (state.relayInfo && state.relayInfo.model)){
      els.modelStatusPill.title = meta.model || state.relayInfo.model || '';
    } else {
    els.modelStatusPill.removeAttribute('title');
    }
  }
}

function setModelSpinner(visible){
  if (!els.modelSpinner) return;
  els.modelSpinner.classList.toggle('hidden', !visible);
}

function setModelMetrics(latencyMs, tps){
  if (els.modelLatency){
    els.modelLatency.textContent = `Latency · ${latencyMs ? `${Math.round(latencyMs)}ms` : '—'}`;
  }
  if (els.modelTps){
    if (tps !== undefined && tps !== null && !Number.isNaN(Number(tps))){
      els.modelTps.textContent = `TPS · ${Number(tps).toFixed(2)}`;
    } else {
      els.modelTps.textContent = 'TPS · —';
    }
  }
}

function setNknStatus(level, label, peers){
  if (!els.nknStatusChat) return;
  const normalizedLevel = (level || '').toLowerCase();
  const normalizedLabel = (label || '').toLowerCase();
  let colorClass = 'status-pink';
  if (normalizedLevel === 'green' || /connected/i.test(normalizedLabel)) {
    colorClass = 'status-green';
  } else if (normalizedLevel === 'yellow' || /connecting/i.test(normalizedLabel)) {
    colorClass = 'status-yellow';
  } else if (
    normalizedLevel === 'red' ||
    /(disconnect|disconnected|error|fail|hard failure|down)/i.test(normalizedLabel)
  ) {
    colorClass = 'status-red';
  }
  applyIndicatorColor(els.nknStatusChat, colorClass);
  const suffix = peers !== undefined ? ` · Peers: ${peers}` : '';
  els.nknStatusChat.textContent = `${label || els.nknStatusChat.textContent}${suffix}`;
}

function getPeerCount(info){
  const payload = info || state.relayInfo || {};
  if (typeof payload.peer_count === 'number'){
    return payload.peer_count;
  }
  return state.session ? 1 : 0;
}

function applyModelStatusEvent(data){
  if (!data) return;
  const phase = data.phase || 'idle';
  setModelMetrics(data.latency_ms, data.tps);
  setModelStatus(phase, data);
  const detail = data.detail || data.description || '';
  const ok = phase !== 'error';
  const activity = detail ? `${phase} · ${detail}` : phase;
  logActivity(`Model ${activity}`, ok);
}

function updateHardwareStats(stats){
  if (!stats || !els.hardwarePanel) return;
  const hasGpu = stats.gpu_available;
  const utilPercent = Math.min(Math.max(Number(stats.gpu_util_percent || 0), 0), 100);
  if (hasGpu && els.gpuUtilBar){
    els.gpuUtilBar.style.width = `${utilPercent}%`;
    els.gpuUtilLabel.textContent = `${utilPercent.toFixed(0)}%`;
  }
  if (hasGpu && els.gpuMemLabel){
    const used = Number(stats.mem_used_mb || 0);
    const total = Number(stats.mem_total_mb || 0);
    els.gpuMemLabel.textContent = `${used} / ${total} MB`;
  }
  if (els.gpuTempLabel){
    els.gpuTempLabel.textContent = `${stats.temperature_c ? `${stats.temperature_c.toFixed(0)}°C` : '—°C'}`;
  }
  if (els.hardwareStatusLabel){
    if (!hasGpu){
      els.hardwareStatusLabel.textContent = stats.error ? stats.error : 'GPU unavailable';
    } else {
      const ready = stats.model_ready ? 'Model ready' : 'Model loading';
      els.hardwareStatusLabel.textContent = `${ready} · ${stats.power_draw_w ? `${stats.power_draw_w.toFixed(1)}W` : ''}`;
    }
  }
  if (els.sessionHardwareInline){
    els.sessionHardwareInline.dataset.gpuAvailable = hasGpu ? 'true' : 'false';
    if (els.sessionGpuUtilBarInline){
      els.sessionGpuUtilBarInline.style.width = hasGpu ? `${utilPercent}%` : '0%';
    }
    if (els.sessionGpuUtilLabelInline){
      els.sessionGpuUtilLabelInline.textContent = hasGpu ? `${utilPercent.toFixed(0)}%` : '—%';
    }
  }
}

setModelStatus(state.modelStatus.phase, { description: state.modelStatus.description });

async function attemptAutoLogin(){
  if (state.autoLoginTried || state.autoLoginInProgress) return null;
  if (!state.savedCreds || state.session) return null;
  state.autoLoginInProgress = true;
  logActivity('Attempting auto login…');
  let result = null;
  try {
    result = await performLogin(state.savedCreds.username, state.savedCreds.password, { auto: true });
    if (result && result.success){
      state.autoLoginTried = true;
      return result;
    }
    const invalidCreds = isInvalidCredentialsError(result && result.error);
    if (invalidCreds){
      localStorage.removeItem(AUTO_LOGIN_KEY);
      state.savedCreds = null;
      state.autoLoginTried = true;
      prefillSavedCreds();
    } else {
      state.autoLoginTried = false;
    }
    return result;
  } finally {
    state.autoLoginInProgress = false;
  }
}

async function ensureAutoLogin(context = 'auto'){
  if (state.session || !state.savedCreds) return null;
  if (state.autoLoginTried || state.autoLoginInProgress) return null;
  logActivity(`Triggering auto-login with saved credentials (${context})...`);
  return await attemptAutoLogin();
}

function renderBubble(role, content, messageId){
  const wrapper = document.createElement('div');
  wrapper.className = `chat-message chat-message-${role}`;
  if (messageId) {
    wrapper.dataset.messageId = messageId;
  }
  const meta = document.createElement('div');
  meta.className = 'chat-meta';
  meta.textContent = role === 'user' ? 'You' : 'NOVA-Q';
  const bubble = document.createElement('div');
  bubble.className = `chat-bubble chat-bubble-${role}`;
  let body = null;
  if (role === 'assistant'){
    body = document.createElement('div');
    body.className = 'markdown-body';
    bubble.appendChild(body);
  } else {
    bubble.textContent = content;
    recordDisplayedMessageContent(messageId, content);
  }
  wrapper.appendChild(meta);
  wrapper.appendChild(bubble);
  els.chat.appendChild(wrapper);
  els.chat.scrollTop = els.chat.scrollHeight;
  return body;
}

function addReloadAction(body){
  if (!body) return;
  const existing = body.querySelector('.reauth-action');
  if (existing) return;
  const action = document.createElement('div');
  action.className = 'reauth-action';
  const label = document.createElement('span');
  label.textContent = 'Session expired. Reload to re-authenticate.';
  const button = document.createElement('button');
  button.type = 'button';
  button.textContent = 'Reload';
  button.addEventListener('click', () => {
    window.location.reload();
  });
  action.appendChild(label);
  action.appendChild(button);
  body.appendChild(action);
}

function renderHistory(){
  displayedMessageContents.clear();
  els.chat.innerHTML = '';
  state.messages.forEach((msg) => {
    if (!msg || !msg.role) return;
      if (msg.role === 'assistant'){
        const body = renderBubble('assistant', '', msg.id);
        renderMarkdown(body, msg.content || '');
        recordDisplayedMessageContent(msg.id, msg.content || '');

      // Show indicator and refresh button for incomplete messages
      if (msg.is_complete === false) {
        const incomplete = document.createElement('div');
        incomplete.style.cssText = 'margin-top: 8px; padding: 6px 10px; background: rgba(251,191,36,0.1); border: 1px solid rgba(251,191,36,0.3); border-radius: 8px; font-size: 11px; color: #92400e; display: flex; align-items: center; gap: 8px;';
        const isAutoRefreshing = autoRefreshTimer !== null;
        incomplete.innerHTML = `
          <span>${isAutoRefreshing ? '🔄' : '⚠️'} ${isAutoRefreshing ? 'Auto-recovering...' : 'Incomplete (connection interrupted)'}</span>
          <button onclick="refreshIncompleteMessage('${msg.id}')" style="padding: 2px 8px; background: #fbbf24; border: none; border-radius: 4px; cursor: pointer; font-size: 10px; font-weight: 600; color: #78350f;">Refresh Now</button>
        `;
        body.parentElement.appendChild(incomplete);
      }
    } else {
      renderBubble('user', msg.content || '', msg.id);
    }
  });
  // Auto-scroll to bottom after rendering history
  // Use requestAnimationFrame to ensure DOM is fully updated, especially markdown rendering
  requestAnimationFrame(() => {
    els.chat.scrollTop = els.chat.scrollHeight;
  });
  if (typingAnimationActive && currentTypingMessageId) {
    const activeBubble = els.chat.querySelector(`[data-message-id="${currentTypingMessageId}"] .markdown-body`);
    if (activeBubble) {
      currentTypingNode = activeBubble;
      renderMarkdown(currentTypingNode, currentTypingText || '');
    }
  }
  // Check for incomplete messages and start auto-refresh if needed
  checkIncompleteMessages();
}

function renderMarkdown(node, text){
  if (!node) return;
  if (window.marked){
    node.innerHTML = marked.parse(text || '');
  } else {
    node.textContent = text || '';
  }
}

function setBusy(v){
  state.busy = v;
  if (state.session){
    els.sendBtn.disabled = v;
  }
}

// Auto-refresh state
let autoRefreshTimer = null;
const displayedMessageContents = new Map();

function recordDisplayedMessageContent(messageId, text) {
  if (!messageId) return;
  displayedMessageContents.set(messageId, text || '');
}

// Typing animation state
let typingQueue = [];
let typingAnimationActive = false;
let currentTypingNode = null;
let currentTypingText = '';
let currentTypingMessageId = null;
let typingChunkInProgress = false;

function startTypingAnimation(targetNode, messageId = null, initialText = '') {
  if (typingAnimationActive) return; // Already typing

  typingAnimationActive = true;
  currentTypingNode = targetNode;
  currentTypingText = initialText || '';
  currentTypingMessageId = messageId;
  if (currentTypingNode) {
    renderMarkdown(currentTypingNode, currentTypingText);
    recordDisplayedMessageContent(currentTypingMessageId, currentTypingText);
  }

  processTypingQueue();
}

async function processTypingQueue() {
  if (!typingAnimationActive) {
    typingQueue = [];
    typingChunkInProgress = false;
    return;
  }

  if (typingChunkInProgress) {
    return;
  }

  if (typingQueue.length === 0) {
    setTimeout(() => processTypingQueue(), 50);
    return;
  }

  const chunk = typingQueue.shift();
  if (chunk === null) {
    typingAnimationActive = false;
    typingQueue = [];
    currentTypingMessageId = null;
    typingChunkInProgress = false;
    return;
  }

  typingChunkInProgress = true;
  await typeChunk(chunk);
  typingChunkInProgress = false;
  processTypingQueue();
}

async function typeChunk(chunk) {
  if (!chunk) return;
  currentTypingText += chunk;
  renderMarkdown(currentTypingNode, currentTypingText);
  recordDisplayedMessageContent(currentTypingMessageId, currentTypingText);
  els.chat.scrollTop = els.chat.scrollHeight;
  await revealChunkAnimation();
}

async function revealChunkAnimation() {
  if (!currentTypingNode) return;
  return new Promise((resolve) => {
    const overlay = document.createElement('span');
    overlay.className = 'typing-reveal';
    let finished = false;
    const cleanup = () => {
      if (finished) return;
      finished = true;
      if (overlay.parentElement) {
        overlay.remove();
      }
      resolve();
    };
    overlay.addEventListener('animationend', cleanup, { once: true });
    currentTypingNode.appendChild(overlay);
    setTimeout(cleanup, 400);
  });
}

function queueTypingChunk(chunk) {
  typingQueue.push(chunk);
  if (typingAnimationActive) {
    processTypingQueue();
  }
}

function setTypingPlaceholder(text, includeInTyping = false) {
  if (!currentTypingNode) return;
  renderMarkdown(currentTypingNode, text);
  els.chat.scrollTop = els.chat.scrollHeight;
  if (includeInTyping) {
    currentTypingText = text;
    recordDisplayedMessageContent(currentTypingMessageId, currentTypingText);
  }
}

function clearTypingPlaceholder() {
  if (!currentTypingNode) return;
  currentTypingText = '';
  renderMarkdown(currentTypingNode, '');
  recordDisplayedMessageContent(currentTypingMessageId, '');
}

function syncTypingPlaceholderToModelStatus(statusPayload) {
  if (!currentTypingNode) return;
  const payload = statusPayload || state.modelStatus;
  if (!payload) return;
  const phase = payload.phase || 'idle';
  if (phase === 'streaming' || phase === 'error') return;
  const detail = payload.detail || payload.description || '';
  if (!detail) return;
  setTypingPlaceholder(`_${detail}_`);
}

function endTyping() {
  typingQueue.push(null); // Signal end
  processTypingQueue();
}

function stopTyping() {
  typingAnimationActive = false;
  typingQueue = [];
  currentTypingMessageId = null;
  typingChunkInProgress = false;
}

// Global function for incomplete message refresh
window.refreshIncompleteMessage = async function(messageId) {
  try {
    const prevDisplayed = new Map(displayedMessageContents);
    const refreshData = await nknSendRequestWithRetry({ event: 'chat.refresh' }, { maxAttempts: 2, timeoutMs: 5000 });
    if (refreshData && refreshData.messages) {
      state.messages = mergeMessages(state.messages, refreshData.messages);
      renderHistory();
      if (messageId === 'auto') {
        animateAutoRecoverTyping(prevDisplayed);
      }
      if (messageId !== 'auto') {
        toast('Message refreshed');
      }
      logActivity(`Refreshed incomplete message ${messageId}`);
    }
  } catch (err) {
    if (messageId !== 'auto') {
      toast('Refresh failed: ' + (err.message || err), false);
    }
    console.warn('Auto-refresh failed:', err);
  }
};

// Check for incomplete messages and start/stop auto-refresh
function checkIncompleteMessages() {
  const hasIncomplete = state.messages.some(msg => msg.is_complete === false);

  if (hasIncomplete && !autoRefreshTimer) {
    // Start auto-refresh timer
    logActivity('Auto-refresh started for incomplete messages');
    autoRefreshTimer = setInterval(async () => {
      const stillIncomplete = state.messages.some(msg => msg.is_complete === false);
      if (stillIncomplete) {
        await window.refreshIncompleteMessage('auto');
      } else {
        // All complete, stop timer
        clearInterval(autoRefreshTimer);
        autoRefreshTimer = null;
        logActivity('Auto-refresh stopped - all messages complete');
      }
    }, 1000); // Every 1 second
  } else if (!hasIncomplete && autoRefreshTimer) {
    // Stop auto-refresh timer
    clearInterval(autoRefreshTimer);
    autoRefreshTimer = null;
    logActivity('Auto-refresh stopped - all messages complete');
  }
}

function animateAutoRecoverTyping(previousContents) {
  if (!previousContents) return;
  if (autoRefreshTimer === null) return;
  const target = [...state.messages].reverse().find(
    (msg) => msg.role === 'assistant' && msg.is_complete === false
  );
  if (!target || !target.id) return;
  const prevText = previousContents.get(target.id) || '';
  const newText = target.content || '';
  if (newText.length <= prevText.length) return;
  const bubble = els.chat.querySelector(`[data-message-id="${target.id}"] .markdown-body`);
  if (!bubble) return;

  stopTyping();
  startTypingAnimation(bubble, target.id, prevText);
  const diff = newText.substring(prevText.length);
  if (diff) {
    queueTypingChunk(diff);
  }
}

async function handleRegister(event){
  event.preventDefault();
  if (!requireRelay()) return;
  const username = (els.registerUser.value || '').trim();
  const password = els.registerPass.value || '';
  if (!username || !password){
    toast('Username/password required', false);
    return;
  }
  if (password.length < 6){
    toast('Password must be at least 6 characters', false);
    return;
  }
  await ensureRelayReady();
  try {
    const resp = await nknSendRequestWithRetry({ event: 'auth.register', username, password });
    const created = resp && resp.username ? resp.username : username;
    toast(`Account created for ${created}. Logging in...`);
    logActivity(`Register OK (${created})`);
    event.target.reset();

    // Automatically log in after successful registration
    await performLogin(username, password, { auto: false });
  } catch (err){
    toast(err.message || 'Register failed', false);
    logActivity(`Register failed: ${err.message || err}`, false);
  }
}

async function handleLogin(event){
  event.preventDefault();
  if (!requireRelay()) return;
  const username = (els.loginUser.value || '').trim();
  const password = els.loginPass.value || '';
  if (!username || !password){
    toast('Username/password required', false);
    return;
  }
  await performLogin(username, password, { auto: false });
}

async function performLogin(username, password, { auto }) {
  await ensureRelayReady();
  try {
    const resp = await nknSendRequestWithRetry({ event: 'auth.login', username, password });
    const uname = resp.username || username;
    const messages = Array.isArray(resp.messages) ? resp.messages : [];
    const sessions = Array.isArray(resp.sessions) ? resp.sessions : [];
    const currentSessionId = resp.current_session_id || null;

    applyLoginSuccess(uname, sessions, currentSessionId, messages);

    // Save credentials for auto-login on next session
    saveCredentials(username, password);

    toast(`${auto ? 'Auto-signed' : 'Signed'} in as ${uname}`);
    logActivity(`${auto ? 'Auto login' : 'Login'} OK (${uname})`);
    if (!auto) {
      els.input.focus();
      // Clear password fields after manual login
      els.loginPass.value = '';
      els.registerPass.value = '';
    }
    return { success: true };
  } catch (err){
    toast(err.message || 'Login failed', false);
    logActivity(`${auto ? 'Auto login' : 'Login'} failed: ${err.message || err}`, false);
    return { success: false, error: err };
  }
}

function applyLoginSuccess(username, sessions, currentSessionId, messages){
  state.session = { username };
  state.sessions = sessions || [];
  state.currentSessionId = currentSessionId;
  // Add IDs to messages from DB
  state.messages = (messages || []).map(msg => ({
    ...msg,
    id: msg.id || generateMessageId()
  }));
  renderSessions();
  renderHistory();
  updateSessionUI();
  updateClientCount();
}

function updateClientCount(){
  const peers = getPeerCount(state.relayInfo);
  if (peers !== undefined){
    const isAuthed = !!state.session;
    const label = isAuthed ? `Signed in as ${state.session?.username}` : 'Connected';
    setNknStatus(isAuthed ? 'pink' : 'green', label, peers);
  }
}

async function handleLogout(){
  if (!state.session) return;
  try {
    await nknSendRequestWithRetry({ event: 'auth.logout' });
  } catch (err){
    toast(err.message || 'Logout failed', false);
  }
  state.session = null;
  state.sessions = [];
  state.currentSessionId = null;
  state.messages = [];
  // Clear auto-refresh timer
  if (autoRefreshTimer) {
    clearInterval(autoRefreshTimer);
    autoRefreshTimer = null;
  }
  // Stop any active typing animation
  stopTyping();
  renderHistory();
  updateSessionUI();
  // Clear saved credentials
  localStorage.removeItem(AUTO_LOGIN_KEY);
  state.savedCreds = null;
  prefillSavedCreds();
  // Reset modal to connect state
  switchLoginModalState('connect');
}

function generateMessageId(){
  return `msg-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
}

function mergeMessages(localMessages, dbMessages){
  // Merge DB messages with local messages, avoiding duplicates using UUIDs
  const messageMap = new Map();

  // First, add all local messages (they have UUIDs)
  localMessages.forEach(msg => {
    if (msg.id) {
      messageMap.set(msg.id, msg);
    }
  });

  // Then add DB messages, using UUID as key (backend now returns UUIDs as 'id')
  dbMessages.forEach(msg => {
    // If message has UUID and it's already in the map, update with DB version (it might be more complete)
    if (msg.id && messageMap.has(msg.id)) {
      const existing = messageMap.get(msg.id);
      // Update if DB version is more complete or has more content
      if (msg.is_complete || (msg.content && msg.content.length > (existing.content || '').length)) {
        messageMap.set(msg.id, { ...existing, ...msg });
      }
      return;
    }

    // If no UUID, try content-based matching as fallback
    if (!msg.id) {
      let found = false;
      for (const localMsg of messageMap.values()) {
        if (localMsg.role === msg.role && localMsg.content === msg.content) {
          found = true;
          break;
        }
      }
      if (found) return;

      // Add with generated ID
      msg = { ...msg, id: generateMessageId() };
    }

    messageMap.set(msg.id, msg);
  });

  // Convert back to array
  return Array.from(messageMap.values());
}

async function handleSend(event){
  event.preventDefault();
  if (state.pendingSend) return;
  state.pendingSend = true;
  try {
    if (!state.session){
      toast('Sign in first', false);
      return;
    }
    if (!requireRelay()) return;
    await ensureRelayReady();
    if (state.busy) return;
    const text = (els.input.value || '').trim();
    if (!text) return;
    els.input.value = '';

    // Add user message with unique ID to prevent duplicates
    const userMsgId = generateMessageId();
    state.messages.push({ id: userMsgId, role: 'user', content: text });
    renderBubble('user', text, userMsgId);

    let accumulated = '';
    let expectedSeq = 0;
    const deltaBuffer = new Map();  // seq -> delta (for out-of-order deltas)
    const assistantMsgId = generateMessageId();
    const assistantBody = renderBubble('assistant', '', assistantMsgId);
    const assistantMessage = {
      id: assistantMsgId,
      role: 'assistant',
      content: '',
      streaming: true,
      is_complete: false,
    };
    state.messages.push(assistantMessage);
    setBusy(true);

    // Start typing animation for this assistant message
    startTypingAnimation(assistantBody, assistantMsgId);
    setTypingPlaceholder('_Preparing model…_');
    const modelLabel = (state.relayInfo && state.relayInfo.model) || 'model';
    setModelStatus('loading', { model: modelLabel, description: `Loading ${modelLabel}…` });
    let streamingNoted = false;

    const handlers = {
      onDelta(delta, seq, batchSize){
        if (!streamingNoted){
          streamingNoted = true;
          if (state.modelStatus.phase !== 'streaming'){
            setModelStatus('streaming', { model: modelLabel });
          }
          if (currentTypingNode){
            clearTypingPlaceholder();
            assistantMessage.content = '';
          }
        }
        // Handle sequenced deltas (may be batched)
        let chunkToQueue = '';

        if (seq !== undefined) {
          const deltasToAdd = batchSize || 1;
          if (seq === expectedSeq) {
            // In-order delta
            accumulated += delta || '';
            chunkToQueue = delta || '';
            expectedSeq += deltasToAdd;

            // Process any buffered deltas that are now in order
            while (deltaBuffer.has(expectedSeq)) {
              const bufferedDelta = deltaBuffer.get(expectedSeq);
              accumulated += bufferedDelta;
              chunkToQueue += bufferedDelta;
              deltaBuffer.delete(expectedSeq);
              expectedSeq++;
            }
          } else if (seq > expectedSeq) {
            // Out-of-order delta - buffer it
            deltaBuffer.set(seq, delta);
            logActivity(`Buffered out-of-order delta ${seq} (expected ${expectedSeq})`);
            return; // Don't queue out-of-order deltas yet
          } else {
            // Duplicate delta - ignore
            return;
          }
        } else {
          // Legacy: no sequence number
          accumulated += delta || '';
          chunkToQueue = delta || '';
        }

        // Queue the chunk for typing animation instead of rendering immediately
        if (chunkToQueue) {
          queueTypingChunk(chunkToQueue);
        }
        assistantMessage.content = accumulated || currentTypingText || assistantMessage.content || '';
        assistantMessage.streaming = true;
        assistantMessage.is_complete = false;
      },
      onDone(totalSeq, finalContent){
        // Use final content if provided (most reliable)
        if (finalContent && finalContent.length > accumulated.length) {
          accumulated = finalContent;
          // Queue the remaining content that wasn't streamed
          const remaining = finalContent.substring(currentTypingText.length);
          if (remaining) {
            queueTypingChunk(remaining);
          }
          logActivity(`Final sync: updated to ${finalContent.length} chars`);
        }

        // Signal end of typing animation
        endTyping();

        // Check for missing deltas
        if (totalSeq !== undefined && expectedSeq < totalSeq) {
          logActivity(`Warning: Missing deltas. Expected ${totalSeq}, received ${expectedSeq}`, false);
        }

        if (accumulated){
          assistantMessage.content = accumulated;
        }
        assistantMessage.streaming = false;
        assistantMessage.is_complete = true;
        setBusy(false);
        if (state.modelStatus.phase !== 'idle'){
          setModelStatus('idle', { model: modelLabel });
        }

        // Do final DB refresh to ensure we're in sync (merge, don't replace)
        nknSendRequestWithRetry({ event: 'chat.refresh' }, { maxAttempts: 1, timeoutMs: 5000 })
          .then(refreshData => {
            if (refreshData) {
              if (refreshData.messages) {
                state.messages = mergeMessages(state.messages, refreshData.messages);
              }
              if (refreshData.sessions) {
                state.sessions = refreshData.sessions;
                renderSessions();
              }
              if (refreshData.current_session_id) state.currentSessionId = refreshData.current_session_id;
              renderHistory();
              logActivity(`Final DB refresh: ${state.messages.length} messages`);
            }
          })
          .catch(err => console.warn('Final refresh failed:', err));
      },
      onError(err, isPartial){
        const errMsg = err && err.message ? err.message : (typeof err === 'string' ? err : '');
        const isAuthError = typeof errMsg === 'string' && /not_authenticated/i.test(errMsg);
        if (isAuthError){
          stopTyping();
          const promptText = '**Session expired.** Please reload to re-authenticate.';
          renderMarkdown(assistantBody, promptText);
          addReloadAction(assistantBody);
          setBusy(false);
          if (state.modelStatus.phase !== 'idle'){
            setModelStatus('idle', { model: modelLabel });
          }
          assistantMessage.content = promptText;
          assistantMessage.streaming = false;
          assistantMessage.is_complete = false;
          logActivity('Session expired – prompt reload to re-authenticate', false);
          return;
        }

        // Queue any remaining untyped content before stopping
        if (accumulated && accumulated.length > currentTypingText.length) {
          const remaining = accumulated.substring(currentTypingText.length);
          queueTypingChunk(remaining);
          queueTypingChunk('\n\n*[Connection interrupted. Refreshing...]*');
          endTyping(); // Let typing finish gracefully
        } else {
          // Stop typing animation immediately
          stopTyping();
          // Always preserve partial message if we have accumulated content
          if (accumulated) {
            renderMarkdown(assistantBody, accumulated + `\n\n*[Connection interrupted. Refreshing...]*`);
            logActivity(`Partial response received (${accumulated.length} chars), refreshing from DB...`);
          } else {
            // Show loading message instead of error
            renderMarkdown(assistantBody, `*Reconnecting and checking database...*`);
            logActivity(`Connection timeout, requesting DB refresh...`);
          }
        }

        // Auto DB refresh after error to recover content (merge, don't replace)
        setTimeout(() => {
          nknSendRequestWithRetry({ event: 'chat.refresh' }, { maxAttempts: 3, timeoutMs: 8000 })
            .then(refreshData => {
              if (refreshData) {
                if (refreshData.messages) {
                  state.messages = mergeMessages(state.messages, refreshData.messages);
                }
                if (refreshData.sessions) {
                  state.sessions = refreshData.sessions;
                  renderSessions();
                }
                if (refreshData.current_session_id) state.currentSessionId = refreshData.current_session_id;
                renderHistory();
                logActivity(`Auto DB refresh: restored ${state.messages.length} messages`);
                setBusy(false);
              } else {
                renderMarkdown(assistantBody, `**Error:** Unable to connect to relay`);
                setBusy(false);
              }
            })
            .catch(refreshErr => {
              console.warn('Auto DB refresh failed:', refreshErr);
              renderMarkdown(assistantBody, `**Error:** ${err.message || err}`);
              logActivity(`DB refresh failed: ${refreshErr.message || refreshErr}`, false);
              setBusy(false);
            });
        }, 500); // Small delay to allow any pending writes to complete
        if (state.modelStatus.phase !== 'error'){
          setModelStatus('idle', { model: modelLabel });
        }
        assistantMessage.content = accumulated || assistantMessage.content || '';
        assistantMessage.streaming = false;
        assistantMessage.is_complete = false;
      },
    onStatus(statusPayload){
      applyModelStatusEvent(statusPayload);
      syncTypingPlaceholderToModelStatus(statusPayload);
      if (statusPayload && statusPayload.phase === 'loading') {
        const desc = statusPayload.description || statusPayload.detail || `Loading ${(statusPayload.model || modelLabel)}…`;
        setTypingPlaceholder(`_${desc}_`);
        assistantMessage.content = `_${desc}_`;
        assistantMessage.streaming = true;
        assistantMessage.is_complete = false;
      }
    }
    };

    streamViaNkn({
      message: text,
      user_uuid: userMsgId,
      assistant_uuid: assistantMsgId
    }, handlers);
  } finally {
    state.pendingSend = false;
  }
}

function decodePayload(payload){
  if (typeof payload === 'string') return payload;
  if (payload instanceof Uint8Array) return new TextDecoder().decode(payload);
  if (payload && payload.payload) return decodePayload(payload.payload);
  return '';
}

async function ensureNknClient(){
  if (state.nkn.client && state.nkn.ready) return state.nkn.client;
  if (state.nkn.connectPromise) return state.nkn.connectPromise;
  if (!window.nkn || !window.nkn.MultiClient){
    throw new Error('nkn-sdk not loaded');
  }
  setNknStatus('yellow', 'Connecting to NKN…');
  toast('Connecting to NKN…', true);
  const promise = new Promise((resolve, reject) => {
    try {
      const client = new window.nkn.MultiClient({
        identifier: 'loving-web',
        seed: state.nkn.seed,
        numSubClients: 20,
        msgCacheSize: 2048,
        reconnectIntervalMin: 1000,
        reconnectIntervalMax: 6000,
      });
      state.nkn.client = client;
      let resolved = false;
      client.on('connect', () => {
        state.nkn.ready = true;
        state.nkn.addr = String(client.addr || '');
        toast(state.nkn.addr ? `NKN connected · ${state.nkn.addr.slice(0, 12)}…` : 'NKN connected');
        setNknStatus('green', 'Connected');

        // Check relay and trigger auto-login if credentials are saved
        checkRelay()
          .then(async () => {
            await ensureAutoLogin('nkn connect').catch(() => {});
            if (state.session) {
              logActivity('Auto-login successful');
              return;
            }
            if (els.loginModal && els.loginModal.classList.contains('state-connect')) {
              switchLoginModalState('auth');
              logActivity('Connected! Please login or register to continue.');
            }
          })
          .catch((err) => toast(err.message || 'Relay probe failed', false));

        state.nkn.backoffMs = state.nkn.baseBackoffMs;
        if (state.nkn.reconnectTimer){
          clearTimeout(state.nkn.reconnectTimer);
          state.nkn.reconnectTimer = null;
        }
        startNknHealthMonitor();
        if (!resolved){ resolved = true; resolve(client); }
      });
      client.onMessage(({src, payload, payloadType}) => handleNknMessage(src, payload));
      client.on('close', () => {
        state.nkn.ready = false;
        state.nkn.client = null;
        state.nkn.addr = '';
        toast('NKN disconnected', false);
        setNknStatus('red', 'Disconnected');
        stopNknHealthMonitor();
        scheduleNknReconnect('close');
      });
      client.on('error', (err) => {
        console.error('nkn error', err);
        state.nkn.ready = false;
        state.nkn.addr = '';
        toast('NKN error', false);
        setNknStatus('red', 'Error');
        stopNknHealthMonitor();
        scheduleNknReconnect('error');
        if (!resolved){ resolved = true; reject(err); }
      });
    } catch (err){
      reject(err);
    }
  });
  state.nkn.connectPromise = promise.finally(() => { state.nkn.connectPromise = null; });
  return promise;
}

function handleNknMessage(src, payload){
  const text = decodePayload(payload);
  let data;
  try { data = JSON.parse(text); }
  catch {
    // Return false to prevent auto-ACK for malformed messages
    return false;
  }
  const event = data.event;
  const reqId = data.id;
  if (!reqId){
    if (event === 'relay.info'){
      toast('Relay info received');
    } else if (event === 'hardware.stats'){
      updateHardwareStats(data.stats || data);
    }
    // Return false - no auto-ACK needed
    return false;
  }
  const ctx = state.nkn.pending.get(reqId);
  if (!ctx) {
    if (event === 'model.status'){
      applyModelStatusEvent(data);
    }
    // Return false - message not for us
    return false;
  }

  if (ctx.kind === 'stream'){
    if (event === 'chat.delta'){
      // Pass delta with sequence number and batch size
      ctx.handlers.onDelta(data.delta || '', data.seq, data.batch_size);
    } else if (event === 'chat.done'){
      ctx.handlers.onDone(data.total_seq, data.final_content);
      state.nkn.pending.delete(reqId);
      logActivity(`Chat stream done (${reqId})`);
    } else if (event === 'chat.error'){
      // Pass error with partial flag
      ctx.handlers.onError(new Error(data.error || 'relay error'), data.partial);
      state.nkn.pending.delete(reqId);
      logActivity(`Chat stream error (${data.error || 'unknown'})`, false);
    } else if (event === 'chat.ack'){
      // ignore
    } else if (event === 'model.status'){
      if (ctx.handlers.onStatus){
        ctx.handlers.onStatus(data);
      } else {
        applyModelStatusEvent(data);
      }
    }
  } else if (ctx.kind === 'request'){
    clearTimeout(ctx.timer);
    state.nkn.pending.delete(reqId);
    if (event && event.endsWith('.error')){
      const errMsg = data.message || data.error || 'relay error';
      logActivity(`DM error (${event}): ${errMsg}`, false);
      ctx.reject(new Error(errMsg));
    } else if (event === 'chat.error'){
      const errMsg = data.error || 'relay error';
      logActivity(`DM error (${errMsg})`, false);
      ctx.reject(new Error(errMsg));
    } else {
      logActivity(`DM ← ${event || 'response'} (${reqId})`);
      ctx.resolve(data);
    }
  }

  // Return false to prevent automatic ACK - we handle responses manually
  return false;
}

async function nknSendRequest(body, timeoutMs=20000){
  if (!requireRelay()) throw new Error('Relay address required');
  const maxAttempts = 3;

  async function dispatch(attempt){
    const id = `req-${Date.now()}-${Math.floor(Math.random()*1000)}`;
    logActivity(`DM → ${body.event || 'request'} (${id})`);
    const client = await ensureNknClient();
    return new Promise((resolve, reject) => {
      const timer = setTimeout(() => {
        state.nkn.pending.delete(id);
        reject(new Error('Relay request timeout'));
      }, timeoutMs);
      state.nkn.pending.set(id, { kind: 'request', resolve, reject, timer });
      client.send(state.relay, JSON.stringify(Object.assign({ id }, body))).catch((err) => {
        clearTimeout(timer);
        state.nkn.pending.delete(id);
        if (attempt < maxAttempts && shouldRetryNknError(err)){
          logActivity(`Send failed (${err.message || err}). Retrying…`, false);
          resetNknClient();
          dispatch(attempt + 1).then(resolve).catch(reject);
        } else {
          reject(err);
        }
      });
    });
  }

  return dispatch(1);
}

async function nknSendRequestWithRetry(body, options = {}){
  const maxAttempts = options.maxAttempts || 5;
  const timeoutMs = options.timeoutMs || 20000;
  const backoffMs = options.backoffMs || 1000;

  if (!requireRelay()) throw new Error('Relay address required');
  await ensureNknClient();

  for (let attempt = 1; attempt <= maxAttempts; attempt++){
    try {
      const id = `req-${Date.now()}-${Math.floor(Math.random()*10000)}`;
      logActivity(`SYN → ${body.event || 'request'} attempt ${attempt}/${maxAttempts} (${id})`);

      const client = state.nkn.client;
      if (!client) throw new Error('NKN client not ready');

      const response = await new Promise((resolve, reject) => {
        const timer = setTimeout(() => {
          state.nkn.pending.delete(id);
          reject(new Error('Relay request timeout'));
        }, timeoutMs);

        state.nkn.pending.set(id, {
          kind: 'request',
          resolve: (data) => {
            clearTimeout(timer);
            resolve(data);
          },
          reject: (err) => {
            clearTimeout(timer);
            reject(err);
          },
          timer,
          attempt,
          startTime: Date.now()
        });

        const message = Object.assign({ id }, body);
        client.send(state.relay, JSON.stringify(message)).catch((sendErr) => {
          clearTimeout(timer);
          state.nkn.pending.delete(id);
          reject(sendErr);
        });
      });

      logActivity(`ACK ← ${body.event || 'response'} (${id})`, true);
      return response;

    } catch (err){
      const isLastAttempt = attempt >= maxAttempts;
      const shouldRetry = shouldRetryNknError(err);

      if (isLastAttempt || !shouldRetry){
        logActivity(`Request failed after ${attempt} attempts: ${err.message || err}`, false);
        throw err;
      }

      const delay = backoffMs * Math.pow(1.5, attempt - 1);
      logActivity(`Retry ${attempt}/${maxAttempts} failed (${err.message}), waiting ${delay}ms...`, false);
      await new Promise(resolve => setTimeout(resolve, delay));

      // Ensure NKN client is healthy before retry
      try {
        await ensureNknClient();
      } catch (clientErr){
        logActivity(`NKN client recovery failed: ${clientErr.message}`, false);
      }
    }
  }

  throw new Error('Request failed after all retry attempts');
}

async function streamViaNkn(payload, handlers){
  if (!requireRelay()){
    handlers.onError(new Error('Relay address required'));
    return;
  }
  const maxAttempts = 3;

  async function dispatch(attempt){
    const client = await ensureNknClient();
    const reqId = `chat-${Date.now()}-${Math.floor(Math.random()*1000)}`;
    state.nkn.pending.set(reqId, { kind: 'stream', handlers });
    const message = Object.assign({ event: 'chat.begin', id: reqId }, payload);
    logActivity(`Chat stream start (${reqId})`);
    try {
      await client.send(state.relay, JSON.stringify(message));
    } catch (err){
      state.nkn.pending.delete(reqId);
      if (attempt < maxAttempts && shouldRetryNknError(err)){
        logActivity(`Chat send failed (${err.message || err}). Retrying…`, false);
        resetNknClient();
        await new Promise(resolve => setTimeout(resolve, 500 * attempt)); // Backoff
        return dispatch(attempt + 1);
      }
      throw err;
    }
    return reqId;
  }

  try {
    await dispatch(1);
  } catch (err){
    // On complete send failure, trigger auto-refresh instead of showing error
    logActivity(`Chat send failed after retries, triggering auto DB refresh...`, false);
    handlers.onError(err);
  }
}

function copyAddress(){
  if (!state.relay){
    toast('No address to copy', false);
    return;
  }
  if (!navigator.clipboard){
    toast('Clipboard unavailable', false);
    return;
  }
  navigator.clipboard.writeText(state.relay).then(() => {
    toast('Relay address copied');
  }).catch((err) => {
    toast('Copy failed', false);
    console.error(err);
  });
}

function init(){
  els.pubkeyInput.value = state.relayPubkey;

  prefillSavedCreds();
  bindChatInputEvents();
  ensureInputModeMatchesViewport();
  if (state.savedCreds){
    logActivity('Saved credentials loaded');
  }

  syncRelayInputs();
  renderHistory();
  updateSessionUI();

  // Auto-login will happen in checkRelay() after NKN connects
}

// === Session Management ===

function isMobileViewport(){
  return window.matchMedia('(max-width: 640px)').matches;
}

function ensureInputModeMatchesViewport(){
  if (!els.input) return;
  if (isMobileViewport() && els.input.tagName.toLowerCase() === 'textarea'){
    downgradeChatInputToInput();
  }
}

function setSidebarHidden(hidden){
  if (!els.sessionsSidebar) return;
  els.sessionsSidebar.classList.toggle('hidden', hidden);
  if (els.chatInterface) {
    els.chatInterface.classList.toggle('sidebar-hidden', hidden);
  }
}

function toggleSidebar(){
  if (!els.sessionsSidebar) return;
  const willHide = !els.sessionsSidebar.classList.contains('hidden');
  setSidebarHidden(willHide);
}

function renderSessions(){
  if (!state.sessions || state.sessions.length === 0) {
    els.sessionsList.innerHTML = '<div style="padding: 12px; text-align: center; color: var(--text-muted); font-size: 12px;">No chat sessions yet</div>';
    return;
  }

  els.sessionsList.innerHTML = state.sessions.map(session => {
    const isActive = session.id === state.currentSessionId;
    const title = session.title || 'New Chat';
    const messageCount = session.message_count || 0;

    return `
      <div class="session-item ${isActive ? 'active' : ''}" data-session-id="${session.id}">
        <div class="session-item-content">
          <div class="session-item-title">${title}</div>
          <div class="session-item-meta">${messageCount} messages</div>
        </div>
        <button class="session-item-delete" data-session-id="${session.id}" title="Delete">×</button>
      </div>
    `;
  }).join('');

  // Add click handlers
  document.querySelectorAll('.session-item').forEach(item => {
    const sessionId = parseInt(item.dataset.sessionId);
    item.addEventListener('click', (e) => {
      if (!e.target.classList.contains('session-item-delete')) {
        switchToSession(sessionId);
        if (isMobileViewport()) {
          setSidebarHidden(true);
        }
      }
    });
  });

  document.querySelectorAll('.session-item-delete').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const sessionId = parseInt(btn.dataset.sessionId);
      deleteSession(sessionId);
    });
  });
}

async function createNewSession(){
  if (!state.session) return;
  try {
    const resp = await nknSendRequestWithRetry({ event: 'session.create' });
    if (resp.sessions) state.sessions = resp.sessions;
    if (resp.current_session_id) state.currentSessionId = resp.current_session_id;
    if (resp.messages) {
      state.messages = (resp.messages || []).map(msg => ({ ...msg, id: msg.id || generateMessageId() }));
    }
    renderSessions();
    renderHistory();
    toast('New chat started');
    logActivity(`Created new session ${resp.session_id}`);
  } catch (err) {
    toast(`Failed to create session: ${err.message}`, false);
  }
}

async function switchToSession(sessionId){
  if (!state.session || sessionId === state.currentSessionId) return;
  // Stop any active typing animation when switching sessions
  stopTyping();
  try {
    const resp = await nknSendRequestWithRetry({ event: 'session.switch', session_id: sessionId });
    if (resp.current_session_id) state.currentSessionId = resp.current_session_id;
    if (resp.messages) {
      state.messages = (resp.messages || []).map(msg => ({ ...msg, id: msg.id || generateMessageId() }));
    }
    renderSessions();
    renderHistory();
    logActivity(`Switched to session ${sessionId}`);
  } catch (err) {
    toast(`Failed to switch session: ${err.message}`, false);
  }
}

async function deleteSession(sessionId){
  if (!state.session) return;
  if (!confirm('Delete this chat session? This cannot be undone.')) return;
  try {
    const resp = await nknSendRequestWithRetry({ event: 'session.delete', session_id: sessionId });
    if (resp.sessions) state.sessions = resp.sessions;
    if (resp.current_session_id) state.currentSessionId = resp.current_session_id;
    if (resp.messages) {
      state.messages = (resp.messages || []).map(msg => ({ ...msg, id: msg.id || generateMessageId() }));
    }
    renderSessions();
    renderHistory();
    toast('Session deleted');
    logActivity(`Deleted session ${sessionId}`);
  } catch (err) {
    toast(`Failed to delete session: ${err.message}`, false);
  }
}

// === Event Handlers ===

els.pubkeyInput.addEventListener('input', syncRelayInputs);
if (els.copyAddress) els.copyAddress.addEventListener('click', copyAddress);
els.sidebarToggle.addEventListener('click', toggleSidebar);
if (els.sidebarInlineToggle) els.sidebarInlineToggle.addEventListener('click', toggleSidebar);
els.newChatBtn.addEventListener('click', async () => {
  await createNewSession();
  if (isMobileViewport()) {
    setSidebarHidden(true);
  }
});
els.connectBtn.addEventListener('click', async () => {
  if (!requireRelay()) return;
  try {
    await ensureNknClient();
    await checkRelay();
    // Switch to auth state after successful connection
    switchLoginModalState('auth');
    logActivity('Connected! Please login or register to continue.');
  } catch (err){
    toast(String(err), false);
  }
});
els.registerForm.addEventListener('submit', handleRegister);
els.loginForm.addEventListener('submit', handleLogin);
els.logoutBtn.addEventListener('click', handleLogout);
els.form.addEventListener('submit', handleSend);
els.showRegisterBtn.addEventListener('click', showRegisterForm);
els.showLoginBtn.addEventListener('click', showLoginForm);

function setViewportHeight(){
  const vh = window.innerHeight * 0.01;
  document.documentElement.style.setProperty('--vh', `${vh}px`);
}
window.addEventListener('resize', () => {
  setViewportHeight();
  ensureInputModeMatchesViewport();
});
window.addEventListener('orientationchange', () => {
  setViewportHeight();
  ensureInputModeMatchesViewport();
});
setViewportHeight();

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
  if (autoRefreshTimer) {
    clearInterval(autoRefreshTimer);
    autoRefreshTimer = null;
  }
});

init();
</script>
</body>
</html>
